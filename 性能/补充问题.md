  🚨 致命级别问题（Runtime Crash）

   61. MAX_INLINE_IMAGE_SIZE_MB 未定义 (main.js:120) 🔥🔥🔥

     // Line 81
     const MAX_INLINE_IMAGE_SIZE = 5 * 1024 * 1024

     // Line 120 - BUG!
     showToast(`以下图片超过 ${MAX_INLINE_IMAGE_SIZE_MB}MB 未插入：...`)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^ ❌ ReferenceError!

   问题：

     - 变量名不匹配：MAX_INLINE_IMAGE_SIZE vs MAX_INLINE_IMAGE_SIZE_MB
     - 当用户上传超大图片时，应用直接崩溃
     - 未捕获的引用错误 → 整个上传流程中断

   修复：

     const MAX_INLINE_IMAGE_SIZE = 5 * 1024 * 1024
     const MAX_INLINE_IMAGE_SIZE_MB = 5
     // 或者直接用 ${MAX_INLINE_IMAGE_SIZE / (1024*1024)}

   -------------------------------------------------------------------------------

   62. OUTLINE常量未定义 (main.js:351,366,367,381) 🔥🔥🔥

     // Line 336 - 函数内部定义
     const MIN_WIDTH = 200
     const MAX_WIDTH = 600

     // 但 line 351,366,367,381 使用的是：
     startWidth = outlineElement.offsetWidth || OUTLINE_MIN_WIDTH  // ❌ ReferenceError!
     if (newWidth < OUTLINE_MIN_WIDTH) newWidth = OUTLINE_MIN_WIDTH  // ❌
     if (newWidth > OUTLINE_MAX_WIDTH) newWidth = OUTLINE_MAX_WIDTH  // ❌

   问题：

     - 常量名不匹配导致运行时崩溃
     - 用户拖动outline边界 → 应用崩溃
     - 这是一个明显的变量重命名遗留问题

   -------------------------------------------------------------------------------

   63. Toast全局变量未声明 (main.js:412-419) 🔥🔥

     // Line 412-419 使用了这些变量：
     if (activeToast && activeToast.parentElement) {  // ❌ activeToast 未定义
       activeToast.parentElement.removeChild(activeToast)
     }
     window.clearTimeout(toastHideTimer)   // ❌ toastHideTimer 未定义
     window.clearTimeout(toastRemoveTimer) // ❌ toastRemoveTimer 未定义

   问题：

     - 第一次调用 showToast() 会抛出 ReferenceError
     - 代码假设有全局变量但从未声明
     - 应该在文件顶部声明：

     let activeToast = null
     let toastHideTimer = null
     let toastRemoveTimer = null

   -------------------------------------------------------------------------------

   64. vditor.destroy() 未清理全局状态 (main.js:80-83) 🔥🔥

     function initEditor() {
       if (vditor && typeof vditor.destroy === 'function') {
         vditor.destroy()  // ✅ 销毁编辑器
       }
       // ❌ 但没有清理：
       // - MutationObserver (仍在监听)
       // - fixPreviewTooltipBehavior 的事件监听器
       // - initOutlineResizer 的事件监听器

   内存泄漏场景：

     - 用户点击"重试加载编辑器"按钮（line 282）
     - 调用 initEditor() 重新初始化
     - 旧的监听器和Observer未清理
     - 每次重试累积更多监听器

   修复：需要跟踪所有监听器并在destroy时清理

   -------------------------------------------------------------------------------

   ⚠️ 严重逻辑错误

   65. resolveIndexHtml 返回不存在的路径 (main.cjs:30-46) 🔥🔥

     function resolveIndexHtml() {
       const candidates = [...]

       for (const candidate of candidates) {
         if (candidate && fs.existsSync(candidate)) {
           return candidate  // ✅ 找到则返回
         }
       }

       return candidates[candidates.length - 1]  // ❌ 返回最后一个（可能不存在）
     }

   问题：

     - 如果所有候选路径都不存在
     - 返回 ../dist/index.html（可能无效）
     - mainWindow.loadFile() 会失败但没有错误处理

   修复：

     if (allCandidatesFailed) {
       throw new Error('Cannot find index.html')
     }

   -------------------------------------------------------------------------------

   66. resolvePreloadPath 逻辑矛盾 (main.cjs:20-28) ⚠️⚠️

     function resolvePreloadPath() {
       const defaultPath = path.join(__dirname, 'preload.cjs')
       if (!app || !app.isPackaged) {  // ❌ 如果 !app，后面代码会崩溃
         return defaultPath
       }

       const packagedPath = path.join(app.getAppPath(), 'electron', 'preload.cjs')
       //                              ^^^^^^^^^^^^^^^^ 如果 !app 已返回，这里 app 一定存在
       return fs.existsSync(packagedPath) ? packagedPath : defaultPath
     }

   问题1：!app 检查无意义

     - 函数被 createWindow() 调用时，app 必然存在
     - 否则整个Electron都无法启动

   问题2：检查逻辑倒置

     - 应该检查 app.isPackaged 而不是 !app.isPackaged
     - 当前逻辑：开发环境返回默认路径，生产环境检查打包路径
     - 但开发环境也可能需要动态路径

   -------------------------------------------------------------------------------

   67. updateWindowTitle 在错误时机调用 (main.cjs:112,150,159) ⚠️⚠️

     function createWindow() {
       mainWindow = new BrowserWindow({...})
       // ... load URL/File
       updateWindowTitle()  // ❌ 此时 currentFilePath 可能是旧值
       mainWindow.on('closed', () => { mainWindow = null })
     }

   问题：

     - macOS从Dock重新激活应用时
     - createWindow() 被调用，但 currentFilePath 是上次关闭前的值
     - 标题显示错误的文件名

   场景：

     - 打开 file1.md → 标题显示 WOK Editor - file1.md
     - 关闭窗口（不退出应用）
     - 从Dock点击图标 → 创建新窗口
     - 标题仍显示 WOK Editor - file1.md ❌

   -------------------------------------------------------------------------------

   68. handleNewFile 不清空编辑器内容 (main.cjs:157-161) 🔥⚠️

     function handleNewFile() {
       currentFilePath = null
       updateWindowTitle()
       sendToRenderer('menu:new-file')  // 只发送事件
     }

   问题：

     - 主进程清空了 currentFilePath
     - 但如果渲染进程的 onNewFile 监听器失败
     - 编辑器仍显示旧内容，而主进程认为是新文件
     - 状态不一致

   危险场景：

     - 打开 file1.md（内容："重要数据"）
     - Ctrl+N 新建文件
     - 渲染进程JS错误 → vditor.setValue('') 未执行
     - 编辑器仍显示"重要数据"
     - 用户修改为"临时笔记"
     - Ctrl+S 保存 → 覆盖对话框默认为"无标题"
     - 用户可能误以为创建了新文件，实际上可能覆盖原文件

   -------------------------------------------------------------------------------

   69. 文件打开没有大小警告 (main.cjs:148) ⚠️⚠️

     const content = await fsPromises.readFile(filePath, 'utf8')
     // ❌ 直接读取，不检查大小
     currentFilePath = filePath
     updateWindowTitle()
     sendToRenderer('menu:open-file', { filePath, content })

   问题：

     - 用户打开50MB的Markdown文件
     - 一次性读入内存并发送到渲染进程
     - IPC通信可能超时或失败
     - Vditor尝试渲染50MB文本 → 浏览器卡死

   建议：

     const stats = await fsPromises.stat(filePath)
     if (stats.size > 10 * 1024 * 1024) {  // 10MB
       const result = await dialog.showMessageBox({
         type: 'warning',
         message: '文件过大',
         detail: `文件大小为 ${(stats.size / 1024 /
   1024).toFixed(2)}MB，可能导致编辑器卡顿。确定打开？`,
         buttons: ['取消', '打开']
       })
       if (result.response === 0) return
     }

   -------------------------------------------------------------------------------

   70. 写文件没有原子性保护 (main.cjs:163-165) 🔥⚠️

     async function writeContentToFile(targetPath, content) {
       await fsPromises.mkdir(path.dirname(targetPath), { recursive: true })
       await fsPromises.writeFile(targetPath, content, 'utf8')  // ❌ 直接覆盖
     }

   数据丢失风险：

     - 用户保存 file.md（已存在，10KB）
     - 程序开始写入新内容
     - 写入5KB时断电/崩溃
     - 文件损坏，只有5KB不完整数据
     - 原始10KB数据永久丢失

   标准做法：先写临时文件，再原子性重命名

     const tempPath = targetPath + '.tmp'
     await fsPromises.writeFile(tempPath, content, 'utf8')
     await fsPromises.rename(tempPath, targetPath)  // 原子操作

   -------------------------------------------------------------------------------

   🐛 运行时边界情况

   71. 空文件名处理 (main.js:148) ⚠️

     const altText = file.name.replace(/[\[\]]/g, '')
     vditor.insertValue(`![${altText}](${result})\n`)

   问题：

     - 如果 file.name === ''（某些系统允许）
     - 结果：![](data:image/png;base64,...)
     - Markdown解析可能出错

   边界情况：

     - file.name === '[]' → altText === ''
     - file.name === '[[]]' → altText === ''
     - 应该提供默认名称：altText || 'image'

   -------------------------------------------------------------------------------

   72. Toast消息为空字符串 (main.js:410) ⚠️

     function showToast(message) {
       if (!message) return  // ✅ 检查了 falsy
       // ...
       toast.textContent = message
     }

   边界情况：

     - showToast('') → 不显示（正确）
     - showToast('   ') → 显示空白Toast（错误）
     - 应该：if (!message || !message.trim()) return

   -------------------------------------------------------------------------------

   73. 路径分隔符硬编码 (main.cjs:127) ⚠️

     const suffix = currentFilePath ? ` - ${path.basename(currentFilePath)}` : ''

   跨平台问题：

     - path.basename() 可以处理
     - 但如果其他地方手动拼接路径：
       - Windows: C:\Users\...
       - macOS: /Users/...
     - 应该统一使用 path.join() 而不是字符串拼接

   -------------------------------------------------------------------------------

   74. defaultContent 包含未转义字符 (main.js:16-75) ⚠️

     const defaultContent = `# 欢迎使用 WOK Editor
     ...
     \`\`\`javascript
     // 代码块示例
     function hello() {
       // console.log("Hello, WOK Editor!");  // ❌ 注释掉的代码
     }
     \`\`\`

   问题：

     - 给用户的示例代码是注释掉的
     - 用户可能困惑为什么点击运行没反应
     - 应该提供可运行的示例或明确说明

   -------------------------------------------------------------------------------

   75. retryButton 没有防抖 (main.js:280-283) ⚠️

     retryButton.addEventListener('click', () => {
       editorElement.innerHTML = ''
       initEditor()  // ❌ 用户可能连续点击
     })

   问题：

     - 用户焦急地快速点击"重试"按钮5次
     - 同时初始化5个Vditor实例
     - 造成内存激增和UI冻结

   修复：

     let retrying = false
     retryButton.addEventListener('click', () => {
       if (retrying) return
       retrying = true
       retryButton.disabled = true
       // ...
     })

   -------------------------------------------------------------------------------

   🔍 CSS层叠问题

   76. CSS规则自相矛盾 (style.css:162,182,194,200) 🔥⚠️

     /* Line 160-162 */
     .vditor-toolbar__item {
       border-radius: 6px !important;
       transition: background-color 0.15s ease !important;  /* ✅ 启用过渡 */
     }

     /* Line 181-184 */
     .vditor-toolbar {
       transition: none !important;  /* ❌ 禁用过渡 */
     }

     /* Line 193-196 */
     .vditor * {
       transition: none !important;  /* ❌ 禁用所有过渡（包括上面的） */
     }

     /* Line 199-201 */
     .vditor-toolbar__item {
       transition: none !important;  /* ❌ 再次禁用 */
     }

   问题：

     - 同一个元素被定义3次
     - 最后 vditor * 会覆盖所有
     - 但 !important 的优先级取决于顺序
     - 浏览器可能出现不可预测的行为

   实际效果：

     - Line 194 的 .vditor * 会覆盖 line 162
     - 所以 line 162 的 transition 完全无效
     - 应该删除line 162，或者调整选择器优先级

   -------------------------------------------------------------------------------

   77. z-index层级混乱 (style.css:45,110,114,119) ⚠️

     .outline-resizer {
       z-index: 100;      /* Line 45 */
     }

     .vditor-tooltip {
       z-index: 99999 !important;  /* Line 110 */
     }

     .vditor-menu {
       z-index: 1000 !important;   /* Line 114 */
     }

     .vditor-toolbar .vditor-menu--current {
       z-index: 1001 !important;   /* Line 119 */
     }

   问题：

     - tooltip层级最高（99999）
     - 但menu只有1000
     - 如果同时显示tooltip和menu，tooltip会覆盖menu
     - 逻辑应该是：menu (10000) > tooltip (9999) > resizer (100)

   -------------------------------------------------------------------------------

   78. !important 过度使用 (style.css 全文) ⚠️⚠️

     /* 统计：约47处 !important */
     height: 100% !important;
     border: none !important;
     background: transparent !important;
     /* ... */

   问题：

     - 维护困难：要覆盖必须再加 !important
     - 表明对CSS特异性理解不足
     - 应该通过正确的选择器优先级实现

   例如：

     /* 不好 */
     .vditor { border: none !important; }

     /* 更好 */
     #app .editor-wrapper .vditor { border: none; }

   -------------------------------------------------------------------------------

   🎯 Electron特定问题

   79. 窗口最小化后内存不释放 (main.cjs:113-115) ⚠️

     mainWindow.on('closed', () => {
       mainWindow = null  // ✅ 设置为null
     })
     // ❌ 但没有释放 currentFilePath 等全局变量

   内存泄漏：

     - macOS上关闭窗口不退出应用
     - currentFilePath 仍保持引用
     - 如果文件内容很大，内存不会释放
     - 应该也清空：currentFilePath = null

   -------------------------------------------------------------------------------

   80. DevTools热键未实现 (main.cjs:102,109) ⚠️

     if (!app.isPackaged) {
       mainWindow.webContents.openDevTools({ mode: 'detach' })
     }
     // ❌ 生产环境没有F12快捷键

   调试困难：

     - 用户报告bug但无法查看控制台
     - 应该添加：

     mainWindow.webContents.on('before-input-event', (event, input) => {
       if (input.key === 'F12') {
         mainWindow.webContents.toggleDevTools()
       }
     })

   -------------------------------------------------------------------------------

   81. app.on('open-file') 在Windows不工作 (main.cjs:301-316) ⚠️⚠️

     app.on('open-file', (_event, filePath) => {
       // ❌ 这个事件只在 macOS 触发
       // Windows 和 Linux 不支持

   跨平台bug：

     - macOS双击.md文件 → 打开应用并加载文件 ✅
     - Windows双击.md文件 → 打开应用，但文件不加载 ❌

   修复：Windows需要从 process.argv 读取文件路径

   -------------------------------------------------------------------------------

   82. 没有处理系统休眠恢复 ⚠️

   功能缺失：

     - 用户编辑文件
     - 电脑进入休眠
     - 恢复后，文件可能被其他程序修改
     - 但应用不知道，用户保存会覆盖

   建议：

     powerMonitor.on('resume', () => {
       if (currentFilePath) {
         // 检查文件是否被修改
         // 提示用户重新加载
       }
     })
