  已完成修改：✅

  🔴 严重逻辑错误

   1. 内存泄漏 - Toast累积 (main.js:356-389) ⚠️⚠️⚠️

     function showToast(message) {
       const toast = document.createElement('div')
       // ... 创建并添加到DOM
       setTimeout(() => {
         document.body.removeChild(toast)  // ❌ 可能失败
       }, 2300)
     }

   问题：

     - 如果用户快速触发多个操作（如连续保存），多个toast同时存在
     - removeChild 可能在元素已被移除时抛出异常
     - setTimeout引用可能在页面卸载时未清理

   修复：

     function showToast(message) {
       const toast = document.createElement('div')
       // ...
       setTimeout(() => {
         if (toast.parentNode) {  // ✅ 检查存在性
           toast.parentNode.removeChild(toast)
         }
       }, 2300)
     }

   处理进度：

     - [✅ 已修复] `showToast` 现复用单个提示节点并在展示前清理既有定时器，隐藏阶段和移除阶段均做空指针防护，避免快速触发导致的残留或异常。

   -------------------------------------------------------------------------------

   2. 事件监听器泄漏 (main.js:322-335) ⚠️⚠️⚠️

     resizer.addEventListener('mousedown', (event) => {
       // ...
       document.addEventListener('mousemove', handleMouseMove)
       document.addEventListener('mouseup', stopResizing)
       window.addEventListener('blur', stopResizing)
     })

   问题：

     - 每次mousedown都添加新的监听器，但从未移除旧的
     - 如果用户快速点击拖拽，会累积大量监听器
     - handleMouseMove 在每次拖拽时都是新函数，无法正确移除

   性能影响：

     - 200次拖拽 = 600个事件监听器
     - 每次mousemove触发200+次回调

   修复：需要将监听器存储并在添加前移除旧的

   处理进度：

     - [✅ 已修复] `initOutlineResizer` 为拖拽句柄建立清理方案，复用 `cleanupOutlineEnhancements()` 管理事件与 DOM，停止拖拽时移除 `mousemove`/`mouseup`/`blur` 监听并通过 `WeakSet` 防止重复绑定。

   -------------------------------------------------------------------------------

   3. MutationObserver 永不断开 (main.js:338-346) ⚠️⚠️

     const observer = new MutationObserver((mutationsList) => {
       // ...
     })
     observer.observe(editorElement, { childList: true, subtree: true })
     // ❌ 永远不会调用 observer.disconnect()

   问题：

     - 在页面整个生命周期内持续监听所有DOM变化
     - subtree: true 监听所有子元素，性能开销大
     - 没有清理机制

   性能影响：

     - 编辑器每次DOM变化都触发回调
     - 长时间使用会累积大量mutation记录

   处理进度：

     - [✅ 已修复] 观察者引用由 `cleanupOutlineEnhancements()` 接管，初始化与 `beforeunload` 均会断开；并在重建时先执行上一次的清理，避免持续监听。

   -------------------------------------------------------------------------------

   4. 竞态条件 - vditor全局变量 (main.js:62,396-430) ⚠️⚠️

     let vditor = null  // 全局变量

     function setupElectronHandlers() {
       window.electronAPI.onNewFile(() => {
         if (vditor) {  // ❌ 可能在初始化完成前被调用
           vditor.setValue('')
         }
       })
     }

     document.addEventListener('DOMContentLoaded', () => {
       initEditor()  // 异步初始化
       setupElectronHandlers()  // 立即注册
     })

   问题：

     - Vditor初始化是异步的（line 204 after 回调）
     - 但立即注册了事件监听器
     - 如果用户在初始化完成前按Ctrl+N，会静默失败

   处理进度：

     - [✅ 已修复] 引入 `editorReadyPromise` 与 `executeWithEditor()` 包装 IPC 回调，所有编辑器交互在初始化完成后顺序执行，避免竞态。

   -------------------------------------------------------------------------------

   5. 文件上传并发处理错误 (main.js:78-147) ⚠️⚠️⚠️

     fileArray.forEach((file) => {
       // ...
       reader.onload = () => {
         vditor.insertValue(`![${altText}](${result})\n`)  // ❌ 并发插入
         successCount += 1
       }
     })

   严重问题：

     - 多个图片同时调用 insertValue，没有顺序保证
     - successCount 在多个异步回调中修改（非原子操作）
     - 如果插入10张图片，可能出现：
       - 图片顺序乱序
       - 多个Toast同时弹出（性能问题1叠加）

   处理进度：

     - [✅ 已修复] 图片上传流程将 FileList 拆分为有序数组，逐项收集 `markdownSnippets` 并在全量读取完成后一次性插入，保证顺序与渲染性能。
     - [✅ 已修复] 结合 1MB 内联阈值过滤大图，将超限与失败文件分别收集后以 Toast 告知。

   -------------------------------------------------------------------------------

   6. 缺少错误处理的IPC调用 (main.js:414,425) ⚠️

     const result = await window.electronAPI.saveFile(content)
     if (result.success) {  // ❌ 没有处理失败情况
       showToast(`文件已保存`)
     }
     // 如果 result.success = false, 用户不知道失败了

   问题：

     - 保存失败时用户无任何提示
     - result.error 被忽略

   处理进度：

     - [✅ 已修复] `setupElectronHandlers` 内新增统一的错误处理包装，`saveFile`/`saveFileAs` 均会在 IPC 或主进程失败时显示错误 Toast，并在控制台输出详细堆栈供调试。

   -------------------------------------------------------------------------------

   7. 文件路径竞态条件 (electron/main.cjs:301-316) ⚠️⚠️

   处理进度：

     - [✅ 已修复] 使用 `ensureWindowReady()` 替换固定的 100ms 延迟，等待窗口 `did-finish-load` 后再派发 `menu:open-file`。
     - [✅ 已修复] 将文件读取改为 `readRendererFile()`，在同一流程中复用大小限制校验。

   -------------------------------------------------------------------------------

   8. 预览按钮tooltip修复逻辑缺陷 (main.js:253-258,261-272) ⚠️

     toolbar.addEventListener('click', (e) => {
       const target = e.target.closest('.vditor-toolbar__item')
       if (isPreviewBtn(target)) {
         hideTooltip(target)
       }
     })
     // ❌ 事件监听器永不移除

   问题：

     - 如果Vditor重新渲染toolbar，旧的监听器仍在
     - 可能导致多个相同监听器累积

   另一个问题：

     disablePreviewTooltip()  // line 272
     // ❌ 只执行一次，如果toolbar重新渲染会失效

   处理进度：

     - [✅ 已修复] `fixPreviewTooltipBehavior()` 现在在每次初始化前执行上一次的拆卸逻辑，MutationObserver 也改为增量遍历新增节点，确保 tooltip 清理与事件卸载同步进行。

   -------------------------------------------------------------------------------

   ⚡ 严重性能问题

   9. CSS选择器性能 (style.css:162,181,193,199,204,208) ⚠️⚠️

     .vditor-toolbar__item {
       transition: background-color 0.15s ease !important;  /* line 162 */
     }
     .vditor-toolbar {
       transition: none !important;  /* line 182 - 覆盖上面的规则 */
     }
     .vditor * {
       transition: none !important;  /* line 194 - 全局覆盖 */
     }
     .vditor-toolbar__item {
       transition: none !important;  /* line 200 - 重复定义 */
     }

   问题：

     - .vditor * 通配符选择器极其低效
     - 浏览器需要检查vditor下的每个元素
     - vditor-toolbar__item 被定义3次，冲突且冗余
     - 大量 !important 降低CSS优先级计算效率

   性能影响：

     - 编辑器每次重绘都要计算数千条规则
     - 估计降低渲染性能30-50%

   处理进度：

     - [✅ 已修复] `src/style.css` 移除 `.vditor *` 通配符及重复 `transition` 禁用段，保留必要的按钮过渡并统一在单条规则中定义。

   -------------------------------------------------------------------------------

   10. 大文件Base64内联风险 (main.js:81,145) ⚠️⚠️⚠️

   处理进度：

     - [✅ 已修复] 将 `MAX_INLINE_IMAGE_SIZE_MB` 下调至 1MB，并在批处理插入前过滤超限文件，提示未插入的文件列表。
     - [✅ 已修复] 图片上传改为收集 `markdownSnippets` 后一次性合并写入，避免插入顺序错乱及多次 editor 重绘。

   -------------------------------------------------------------------------------

   11. 文件读取无大小限制 (electron/main.cjs:148) ⚠️⚠️

   处理进度：

     - [✅ 已修复] 新增 `MAX_RENDERER_FILE_SIZE = 10MB` 常量及 `readRendererFile()`，在读取前获取 `stat` 校验文件体积。
     - [✅ 已修复] 超出限制时抛出自定义 `FILE_TOO_LARGE` 错误，并通过对话框提示用户实际大小与限制值。

   -------------------------------------------------------------------------------

   12. vditor.resize()频繁调用 (main.js:317-319) ⚠️

     const handleMouseMove = (event) => {
       // ...
       outlineElement.style.width = `${newWidth}px`
       if (vditor) {
         vditor.resize()  // ❌ 每次mousemove都调用
       }
     }

   性能影响：

     - 拖拽时每毫秒触发数十次
     - resize() 可能触发重排和重绘
     - 建议：使用节流（throttle）限制到每100ms一次

   处理进度：

     - [✅ 已修复] 拖拽回调利用 `requestAnimationFrame` 合并连续的 `resize()` 调用，并在释放时取消挂起帧，显著降低高频重排。

   -------------------------------------------------------------------------------

   13. querySelectorAll在循环中 (main.js:262,341) ⚠️

     const items = toolbar.querySelectorAll('.vditor-toolbar__item')  // 遍历所有按钮
     items.forEach((el) => {
       if (!isPreviewBtn(el)) return
       // ...
     })

   问题：

     - 每次调用都重新查询DOM
     - 应该缓存结果或使用事件委托

   处理进度：

     - [✅ 已修复] Toolbar 与目录增强改用堆栈遍历新增节点，不再重复 `querySelectorAll`，并通过 `WeakSet` 记录已处理按钮。

   -------------------------------------------------------------------------------

   🐛 其他逻辑问题

   14. IPC处理器重复注册 (electron/main.cjs:238-281,286) ⚠️

     app.whenReady().then(() => {
       createWindow()
       registerIpcHandlers()  // 注册一次

       app.on('activate', () => {
         if (mainWindow === null) {
           createWindow()
           // ❌ 没有再次调用 registerIpcHandlers()
         }
       })
     })

   问题：

     - ipcMain.handle 在全局注册，不是针对特定窗口
     - 但窗口关闭后，处理器仍引用旧的 currentFilePath
     - macOS上关闭窗口再激活会出现状态不一致

   处理进度：

     - [✅ 已修复] `registerIpcHandlers()` 增加幂等守卫并在 `app.on('activate')` 中重用，确保窗口重建后仍可响应且不会重复注册。
     - [✅ 已修复] 主窗口关闭时重置 `currentFilePath`，避免新窗口引用过期路径。

   -------------------------------------------------------------------------------

   15. 错误处理丢失堆栈 (electron/main.cjs:254,271) ⚠️

     } catch (error) {
       console.error('保存文件失败:', error)  // ❌ 只记录
       return { success: false, error: error.message }  // 丢失堆栈
     }

   问题：

     - error.message 不包含堆栈信息
     - 生产环境调试困难
     - 建议：返回 error.stack 或使用日志系统

   处理进度：

     - [✅ 已修复] 新增 `buildErrorResponse()`，在开发模式下随 IPC 响应一并返回 `error.stack`，渲染进程收到失败结果时也会输出堆栈。

   -------------------------------------------------------------------------------

   16. 未处理的Promise拒绝 (main.js:411-429) ⚠️

     window.electronAPI.onSaveFile(async () => {
       if (vditor) {
         const result = await window.electronAPI.saveFile(content)
         // ❌ 没有 try-catch
       }
     })

   问题：

     - IPC通信失败会导致未捕获的Promise拒绝
     - 应该添加try-catch

   处理进度：

     - [✅ 已修复] `executeWithEditor()` 统一包裹 IPC 回调并在内部捕获异常，事件回调直接返回该 Promise，避免未处理的拒绝。
     - [✅ 已修复] 保存相关回调会在 Toast 中提示失败，并在开发模式记录堆栈。

   -------------------------------------------------------------------------------

   17. 窗口标题更新时机错误 (electron/main.cjs:112) ⚠️

     function createWindow() {
       // ... 创建窗口
       updateWindowTitle()  // ❌ 此时 currentFilePath 可能已过时
     }

   问题：

     - macOS上从Dock重新打开时，标题显示上次的文件名
     - 应该在每次显示窗口时更新

   处理进度：

     - [✅ 已修复] 关闭窗口时清空 `currentFilePath` 并在窗口获取焦点时重新调用 `updateWindowTitle()`，确保重新打开后标题同步。

