   🔴 严重逻辑错误

   1. 内存泄漏 - Toast累积 (main.js:356-389) ⚠️⚠️⚠️

     function showToast(message) {
       const toast = document.createElement('div')
       // ... 创建并添加到DOM
       setTimeout(() => {
         document.body.removeChild(toast)  // ❌ 可能失败
       }, 2300)
     }

   问题：

     - 如果用户快速触发多个操作（如连续保存），多个toast同时存在
     - removeChild 可能在元素已被移除时抛出异常
     - setTimeout引用可能在页面卸载时未清理

   修复：

     function showToast(message) {
       const toast = document.createElement('div')
       // ...
       setTimeout(() => {
         if (toast.parentNode) {  // ✅ 检查存在性
           toast.parentNode.removeChild(toast)
         }
       }, 2300)
     }

   -------------------------------------------------------------------------------

   2. 事件监听器泄漏 (main.js:322-335) ⚠️⚠️⚠️

     resizer.addEventListener('mousedown', (event) => {
       // ...
       document.addEventListener('mousemove', handleMouseMove)
       document.addEventListener('mouseup', stopResizing)
       window.addEventListener('blur', stopResizing)
     })

   问题：

     - 每次mousedown都添加新的监听器，但从未移除旧的
     - 如果用户快速点击拖拽，会累积大量监听器
     - handleMouseMove 在每次拖拽时都是新函数，无法正确移除

   性能影响：

     - 200次拖拽 = 600个事件监听器
     - 每次mousemove触发200+次回调

   修复：需要将监听器存储并在添加前移除旧的

   -------------------------------------------------------------------------------

   3. MutationObserver 永不断开 (main.js:338-346) ⚠️⚠️

     const observer = new MutationObserver((mutationsList) => {
       // ...
     })
     observer.observe(editorElement, { childList: true, subtree: true })
     // ❌ 永远不会调用 observer.disconnect()

   问题：

     - 在页面整个生命周期内持续监听所有DOM变化
     - subtree: true 监听所有子元素，性能开销大
     - 没有清理机制

   性能影响：

     - 编辑器每次DOM变化都触发回调
     - 长时间使用会累积大量mutation记录

   -------------------------------------------------------------------------------

   4. 竞态条件 - vditor全局变量 (main.js:62,396-430) ⚠️⚠️

     let vditor = null  // 全局变量

     function setupElectronHandlers() {
       window.electronAPI.onNewFile(() => {
         if (vditor) {  // ❌ 可能在初始化完成前被调用
           vditor.setValue('')
         }
       })
     }

     document.addEventListener('DOMContentLoaded', () => {
       initEditor()  // 异步初始化
       setupElectronHandlers()  // 立即注册
     })

   问题：

     - Vditor初始化是异步的（line 204 after 回调）
     - 但立即注册了事件监听器
     - 如果用户在初始化完成前按Ctrl+N，会静默失败

   -------------------------------------------------------------------------------

   5. 文件上传并发处理错误 (main.js:78-147) ⚠️⚠️⚠️

     fileArray.forEach((file) => {
       // ...
       reader.onload = () => {
         vditor.insertValue(`![${altText}](${result})\n`)  // ❌ 并发插入
         successCount += 1
       }
     })

   严重问题：

     - 多个图片同时调用 insertValue，没有顺序保证
     - successCount 在多个异步回调中修改（非原子操作）
     - 如果插入10张图片，可能出现：
       - 图片顺序乱序
       - 多个Toast同时弹出（性能问题1叠加）

   -------------------------------------------------------------------------------

   6. 缺少错误处理的IPC调用 (main.js:414,425) ⚠️

     const result = await window.electronAPI.saveFile(content)
     if (result.success) {  // ❌ 没有处理失败情况
       showToast(`文件已保存`)
     }
     // 如果 result.success = false, 用户不知道失败了

   问题：

     - 保存失败时用户无任何提示
     - result.error 被忽略

   -------------------------------------------------------------------------------

   7. 文件路径竞态条件 (electron/main.cjs:301-316) ⚠️⚠️

     app.on('open-file', (_event, filePath) => {
       if (mainWindow === null) {
         createWindow()  // 异步创建窗口
       }
       setTimeout(async () => {  // ❌ 固定延迟不可靠
         const content = await fsPromises.readFile(filePath, 'utf8')
         sendToRenderer('menu:open-file', { filePath, content })
       }, 100)
     })

   问题：

     - 100ms的延迟是任意的
     - 窗口创建可能需要更长时间
     - 在慢速机器上会导致消息发送失败

   -------------------------------------------------------------------------------

   8. 预览按钮tooltip修复逻辑缺陷 (main.js:253-258,261-272) ⚠️

     toolbar.addEventListener('click', (e) => {
       const target = e.target.closest('.vditor-toolbar__item')
       if (isPreviewBtn(target)) {
         hideTooltip(target)
       }
     })
     // ❌ 事件监听器永不移除

   问题：

     - 如果Vditor重新渲染toolbar，旧的监听器仍在
     - 可能导致多个相同监听器累积

   另一个问题：

     disablePreviewTooltip()  // line 272
     // ❌ 只执行一次，如果toolbar重新渲染会失效

   -------------------------------------------------------------------------------

   ⚡ 严重性能问题

   9. CSS选择器性能 (style.css:162,181,193,199,204,208) ⚠️⚠️

     .vditor-toolbar__item {
       transition: background-color 0.15s ease !important;  /* line 162 */
     }
     .vditor-toolbar {
       transition: none !important;  /* line 182 - 覆盖上面的规则 */
     }
     .vditor * {
       transition: none !important;  /* line 194 - 全局覆盖 */
     }
     .vditor-toolbar__item {
       transition: none !important;  /* line 200 - 重复定义 */
     }

   问题：

     - .vditor * 通配符选择器极其低效
     - 浏览器需要检查vditor下的每个元素
     - vditor-toolbar__item 被定义3次，冲突且冗余
     - 大量 !important 降低CSS优先级计算效率

   性能影响：

     - 编辑器每次重绘都要计算数千条规则
     - 估计降低渲染性能30-50%

   -------------------------------------------------------------------------------

   10. 大文件Base64内联风险 (main.js:81,145) ⚠️⚠️⚠️

     const MAX_INLINE_IMAGE_SIZE = 5 * 1024 * 1024  // 5MB
     // ...
     reader.readAsDataURL(file)  // 转换为Base64
     vditor.insertValue(`![${altText}](${result})\n`)

   严重问题：

     - Base64编码会增加33%大小：5MB → 6.65MB
     - 全部内联到Markdown文档中
     - 插入10张5MB图片 = 66.5MB的纯文本
     - 保存文件时写入66.5MB到磁盘
     - 打开文件时读取66.5MB到内存

   性能影响：

     - Vditor需要解析和渲染66.5MB的文本
     - 可能导致浏览器卡死或崩溃
     - 建议：降低到500KB或使用外部文件引用

   -------------------------------------------------------------------------------

   11. 文件读取无大小限制 (electron/main.cjs:148) ⚠️⚠️

     const content = await fsPromises.readFile(filePath, 'utf8')
     // ❌ 没有文件大小检查

   问题：

     - 用户可以打开1GB的Markdown文件
     - 会一次性读入内存并发送到渲染进程
     - 可能导致应用崩溃

   -------------------------------------------------------------------------------

   12. vditor.resize()频繁调用 (main.js:317-319) ⚠️

     const handleMouseMove = (event) => {
       // ...
       outlineElement.style.width = `${newWidth}px`
       if (vditor) {
         vditor.resize()  // ❌ 每次mousemove都调用
       }
     }

   性能影响：

     - 拖拽时每毫秒触发数十次
     - resize() 可能触发重排和重绘
     - 建议：使用节流（throttle）限制到每100ms一次

   -------------------------------------------------------------------------------

   13. querySelectorAll在循环中 (main.js:262,341) ⚠️

     const items = toolbar.querySelectorAll('.vditor-toolbar__item')  // 遍历所有按钮
     items.forEach((el) => {
       if (!isPreviewBtn(el)) return
       // ...
     })

   问题：

     - 每次调用都重新查询DOM
     - 应该缓存结果或使用事件委托

   -------------------------------------------------------------------------------

   🐛 其他逻辑问题

   14. IPC处理器重复注册 (electron/main.cjs:238-281,286) ⚠️

     app.whenReady().then(() => {
       createWindow()
       registerIpcHandlers()  // 注册一次

       app.on('activate', () => {
         if (mainWindow === null) {
           createWindow()
           // ❌ 没有再次调用 registerIpcHandlers()
         }
       })
     })

   问题：

     - ipcMain.handle 在全局注册，不是针对特定窗口
     - 但窗口关闭后，处理器仍引用旧的 currentFilePath
     - macOS上关闭窗口再激活会出现状态不一致

   -------------------------------------------------------------------------------

   15. 错误处理丢失堆栈 (electron/main.cjs:254,271) ⚠️

     } catch (error) {
       console.error('保存文件失败:', error)  // ❌ 只记录
       return { success: false, error: error.message }  // 丢失堆栈
     }

   问题：

     - error.message 不包含堆栈信息
     - 生产环境调试困难
     - 建议：返回 error.stack 或使用日志系统

   -------------------------------------------------------------------------------

   16. 未处理的Promise拒绝 (main.js:411-429) ⚠️

     window.electronAPI.onSaveFile(async () => {
       if (vditor) {
         const result = await window.electronAPI.saveFile(content)
         // ❌ 没有 try-catch
       }
     })

   问题：

     - IPC通信失败会导致未捕获的Promise拒绝
     - 应该添加try-catch

   -------------------------------------------------------------------------------

   17. 窗口标题更新时机错误 (electron/main.cjs:112) ⚠️

     function createWindow() {
       // ... 创建窗口
       updateWindowTitle()  // ❌ 此时 currentFilePath 可能已过时
     }

   问题：

     - macOS上从Dock重新打开时，标题显示上次的文件名
     - 应该在每次显示窗口时更新

